########## .\dinner_club\manage.py ##########
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "dinner_club.settings")
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == "__main__":
    main()


########## .\dinner_club\accounts\admin.py ##########
from django.contrib import admin

# Register your models here.


########## .\dinner_club\accounts\apps.py ##########
from django.apps import AppConfig


class AccountsConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "accounts"


########## .\dinner_club\accounts\models.py ##########
from django.db import models

# Create your models here.


########## .\dinner_club\accounts\tests.py ##########
from django.contrib.auth.models import User
from django.test import TestCase
from django.urls import reverse

class LoginViewTests(TestCase):
    def setUp(self):
        self.user = User.objects.create_user(
            username='testuser',
            password='testpassword'
        )

    def test_correct_login(self):
        response = self.client.post(reverse('login'), {
            'username': 'testuser',
            'password': 'testpassword'
        })

        # Check if the user is authenticated and the response redirects to the default profile URL
        self.assertRedirects(response, '/accounts/profile/')
        self.assertTrue(response.wsgi_request.user.is_authenticated)

    def test_incorrect_login(self):
        response = self.client.post(reverse('login'), {
            'username': 'testuser',
            'password': 'wrongpassword'
        })

        # Check if the user is not authenticated
        self.assertFalse(response.wsgi_request.user.is_authenticated)


########## .\dinner_club\accounts\urls.py ##########
from django.urls import path
from .views import CustomLoginView, signup, CustomLogoutView, profile

urlpatterns = [
    path('login/', CustomLoginView.as_view(), name='login'),
    path('signup/', signup, name='signup'),
    path('logout/', CustomLogoutView.as_view(), name='logout'),
    path('profile/', profile, name='profile'),
]


########## .\dinner_club\accounts\views.py ##########
from django.contrib.auth import login
from django.contrib.auth.decorators import login_required
from django.contrib.auth.forms import UserCreationForm
from django.contrib.auth.views import LoginView, LogoutView
from django.shortcuts import redirect
from django.shortcuts import render


class CustomLoginView(LoginView):
    template_name = 'accounts/login.html'


def signup(request):
    if request.method == 'POST':
        form = UserCreationForm(request.POST)
        if form.is_valid():
            user = form.save()
            login(request, user)
            return redirect('home')
    else:
        form = UserCreationForm()
    return render(request, 'accounts/signup.html', {'form': form})


class CustomLogoutView(LogoutView):  # Add this class
    next_page = 'home'



@login_required
def profile(request):
    return render(request, 'accounts/profile.html')

########## .\dinner_club\accounts\__init__.py ##########


########## .\dinner_club\accounts\migrations\__init__.py ##########


########## .\dinner_club\dinner_club\asgi.py ##########
"""
ASGI config for dinner_club project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/4.1/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "dinner_club.settings")

application = get_asgi_application()


########## .\dinner_club\dinner_club\settings.py ##########
"""
Django settings for dinner_club project.

Generated by 'django-admin startproject' using Django 4.1.7.

For more information on this file, see
https://docs.djangoproject.com/en/4.1/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/4.1/ref/settings/
"""
import os
from pathlib import Path

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent

# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/4.1/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = "django-insecure-lbhy2+y(q78wgq2fz1jbj=1h0pmepwhpphfh-ah4z^0!))o^n3"

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = []

# Application definition

INSTALLED_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    'allauth',
    'allauth.account',
    'allauth.socialaccount',
    'accounts',
    'events',
]

AUTHENTICATION_BACKENDS = (
    'allauth.account.auth_backends.AuthenticationBackend',
)

MIDDLEWARE = [
    "django.middleware.security.SecurityMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
]

ROOT_URLCONF = "dinner_club.urls"

TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.debug",
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
            ],
        },
    },
]

WSGI_APPLICATION = "dinner_club.wsgi.application"

# Database
# https://docs.djangoproject.com/en/4.1/ref/settings/#databases

DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.sqlite3",
        "NAME": BASE_DIR / "db.sqlite3",
    }
}

# Password validation
# https://docs.djangoproject.com/en/4.1/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        "NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.MinimumLengthValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.CommonPasswordValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.NumericPasswordValidator",
    },
]

# Internationalization
# https://docs.djangoproject.com/en/4.1/topics/i18n/

LANGUAGE_CODE = "en-us"

TIME_ZONE = "UTC"

USE_I18N = True

USE_TZ = True

# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/4.1/howto/static-files/

STATIC_URL = '/static/'
STATICFILES_DIRS = [os.path.join(BASE_DIR, 'static')]

# Default primary key field type
# https://docs.djangoproject.com/en/4.1/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = "django.db.models.BigAutoField"



########## .\dinner_club\dinner_club\urls.py ##########
"""dinner_club URL Configuration

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/4.1/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""

from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('accounts/', include('accounts.urls')),
    path('', include('events.urls')),  # Add this line
]


########## .\dinner_club\dinner_club\wsgi.py ##########
"""
WSGI config for dinner_club project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/4.1/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "dinner_club.settings")

application = get_wsgi_application()


########## .\dinner_club\dinner_club\__init__.py ##########


########## .\dinner_club\events\admin.py ##########
from django.contrib import admin

# Register your models here.


########## .\dinner_club\events\apps.py ##########
from django.apps import AppConfig


class EventsConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "events"


########## .\dinner_club\events\calendar_utils.py ##########
import calendar
from datetime import date


def month_calendar(year, month):
    cal = calendar.Calendar()
    weeks = cal.monthdatescalendar(year, month)
    return weeks


########## .\dinner_club\events\forms.py ##########
from django import forms

from .models import DinnerClubEvent


class DinnerClubEventForm(forms.ModelForm):
    class Meta:
        model = DinnerClubEvent
        fields = ['date']
        widgets = {
            'date': forms.DateTimeInput(attrs={'type': 'datetime-local', 'step': '60'}),
        }




########## .\dinner_club\events\models.py ##########
from django.contrib.auth.models import User
from django.db import models


class DinnerClubEvent(models.Model):
    name = models.CharField(max_length=255)
    host = models.ForeignKey(User, on_delete=models.CASCADE)
    date = models.DateTimeField()
    attendees = models.ManyToManyField(User, related_name='attendees', blank=True)

    def __str__(self):
        return self.name

########## .\dinner_club\events\tests.py ##########
from django.test import TestCase

# Create your tests here.


########## .\dinner_club\events\urls.py ##########
from django.urls import path, include
from .views import home, create_event, calendar_view

urlpatterns = [
    path('', home, name='home'),
    path('create/', create_event, name='create_event'),
    path('calendar/', calendar_view, name='calendar'),
]


########## .\dinner_club\events\views.py ##########
from django.shortcuts import render, redirect
from django.contrib.auth.decorators import login_required
from datetime import date

from .calendar_utils import month_calendar
from .models import DinnerClubEvent
from .forms import DinnerClubEventForm


def home(request):
    return render(request, 'events/home.html')


@login_required
def create_event(request):
    if request.method == 'POST':
        form = DinnerClubEventForm(request.POST)
        if form.is_valid():
            event = form.save(commit=False)
            event.host = request.user
            event.save()
            return redirect('home')
    else:
        form = DinnerClubEventForm()
    return render(request, 'events/create_event.html', {'form': form})


@login_required
def calendar_view(request):
    today = date.today()
    events = DinnerClubEvent.objects.filter(date__year=today.year, date__month=today.month)
    weeks = month_calendar(today.year, today.month)
    return render(request, 'events/calendar.html', {'weeks': weeks, 'events': events})


########## .\dinner_club\events\__init__.py ##########


########## .\dinner_club\events\migrations\0001_initial.py ##########
# Generated by Django 4.1.7 on 2023-03-17 08:06

from django.conf import settings
from django.db import migrations, models
import django.db.models.deletion


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name="DinnerClubEvent",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("name", models.CharField(max_length=255)),
                ("date", models.DateTimeField()),
                (
                    "attendees",
                    models.ManyToManyField(
                        blank=True,
                        related_name="attendees",
                        to=settings.AUTH_USER_MODEL,
                    ),
                ),
                (
                    "host",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        to=settings.AUTH_USER_MODEL,
                    ),
                ),
            ],
        ),
    ]


########## .\dinner_club\events\migrations\__init__.py ##########


########## .\dinner_club\events\templatetags\events_extras.py ##########
from django import template

register = template.Library()

@register.filter
def to_date(value):
    return value.date()

########## .\dinner_club\events\templatetags\__init__.py ##########


########## .\tasks\utils.py ##########
import fnmatch
import os

from invoke import task


def find_files(directory, pattern):
    for root, dirs, files in os.walk(directory):
        for basename in files:
            if fnmatch.fnmatch(basename, pattern):
                filename = os.path.join(root, basename)
                yield filename


@task
def concat_python_files(c, output_file='concatenated_python_files.txt'):
    """
    Concatenate all Python files into a single, human-readable file.

    :param c: Invoke context
    :param output_file: The name of the output file (default: concatenated_python_files.txt)
    """
    with open(output_file, 'w') as outfile:
        for file_path in find_files('.', '*.py'):
            with open(file_path, 'r') as infile:
                outfile.write(f'########## {file_path} ##########\n')
                outfile.write(infile.read())
                outfile.write('\n\n')

    print(f'All nested Python files have been concatenated into {output_file}.')

    





########## .\tasks\__init__.py ##########
import os
import importlib
from invoke import Collection, Task

def is_task_module(module_name):
    if not module_name.endswith('.py') or module_name == '__init__.py':
        return False

    module_path = os.path.join(os.path.dirname(__file__), module_name)
    spec = importlib.util.spec_from_file_location(module_name[:-3], module_path)
    module = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(module)

    for name, value in module.__dict__.items():
        if isinstance(value, Task):
            return True

    return False

task_files = [f for f in os.listdir(os.path.dirname(__file__)) if is_task_module(f)]
modules = [importlib.import_module(f'tasks.{f[:-3]}') for f in task_files]

ns = Collection()

for module in modules:
    for name, value in module.__dict__.items():
        if isinstance(value, Task):
            ns.add_task(value)

